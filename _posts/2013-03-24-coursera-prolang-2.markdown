---
layout: post
title: "Coursera Prolang总结2(实现SML中的类型推导)"
date: 2013-03-24 9:27
comments: true
categories: Coursera SML
---

SML是一门静态类型语言, 但是将值绑定新变量的时候可以不指定变量的类型. 这意味着每个变量都是"尽可能地宽松", 比如变量x, 开始时为范型'a, 但是编译器扫到一个a+1的表达式之后, 会自动把x的类型约束为int, 因为加号+的类型是int * int -> int, 即吃一个(int, int)的元组, 返回一个int.

于是自动类型推导就成为一个有意思的活. 我刻意不去查阅相关资料, 做了些思考.

要解决的问题是: 给定n个函数定义, 要推导出这n个函数的类型, 包括参数类型和返回类型.

可以采用待定系数法类似的思路, 先设n个函数各类型为不同的范型参数a1, r1, a2, r2 ... an, rn.

现在, n个函数体就是对这2n个变量的约束. 函数体是一个表达式. 表达式分为if, let, case ...等, 还有函数调用. 每个表达式都有可能包含一些别的表达式.

if产生的约束比较简单, 即要求condition的返回值类型是bool, 要求then分支的返回值类型等于else分支的返回值类型.

let也比较简单, 即binding的类型为相应expression返回类型; 整个表达式返回类型为in块中表达式返回类型.

case稍微复杂些. 首先, patterns能对一个未完全确定的变量(通常是参数或其一部分)提供约束, 这部分在Coursera Prolang的作业中出现; 另外必须保证所有分支的expression的返回值一样, 并且这就是case表达式的返回类型.

函数调用是比较意思的地方. 我们只需要整理出一个巨大的约束集即可, 集合的每个元素形式是: 类型A要能接受类型B. 这里的A和B都可以是"未完成推导的", 也可是是完成了的. 无论如何, A和B都将变成A和B的交集. 这种变化会产生连锁效应, 所以我们应该紧接着更新A的邻居和B的邻居. 这用教科书的话说叫Bellman-Ford, 用咱们的话说叫SPFA :P. 最终当迭代到不动的时候, 推导就完成了.

所以我们需要能将两个类型求交集的能力. 我们把类型们分为两种: 已推导出和未推导出. 已推导出的肯定不能动; 未推导出的会把自己下降到能满足已推导约束的地步, 并且尽量lenient(Dan用的这个词). 如果两个都未推导出来, 那就互相下降自己的分支来满足对方相应的分支(一个类型的结构是一棵树); 当两个范型碰头的时候, 他们会变成同一个.

然后我觉得就没有然后了. 可惜暂时不会去实现它>.<
